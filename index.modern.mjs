import*as t from"@coral-xyz/anchor";import{PublicKey as n,Keypair as e,TransactionMessage as i,VersionedTransaction as r}from"@solana/web3.js";import{getAssociatedTokenAddressSync as a,ASSOCIATED_TOKEN_PROGRAM_ID as s,TOKEN_PROGRAM_ID as o}from"@solana/spl-token";import*as c from"dotenv";const u=new t.web3.PublicKey("G34e7zJuRne2pfDHh9YayixM2rJFdwV624NUzbj9FRR5");function h(t){return n.findProgramAddressSync([Buffer.from("main_account"),Buffer.from(t)],u)[0]}function l(t,e){return n.findProgramAddressSync([Buffer.from("sub_account"),t.toBuffer(),e.toBuffer()],u)[0]}class m{constructor(){this.program=void 0,this.provider=void 0,this.connection=void 0,this.signer=void 0,this.wallet=void 0}static async initialize(){const n=new m;return c.config(),n.wallet=n.loadWallet(),n.signer=n.wallet.payer,n.provider=new t.AnchorProvider(n.loadRpc(),n.wallet,{preflightCommitment:"processed"}),n.connection=n.provider.connection,n.program=n.getProgram("./utils/aisa_contracts.json",n.provider),n}getProgram(n,e){const i=JSON.parse(JSON.stringify(require(n)));return new t.Program(i,e)}loadRpc(){const n=process.env.RPC_URL;if(!n)throw new Error("RPC URL not defined in .env");try{return new t.web3.Connection(n,{commitment:"processed"})}catch(t){throw new Error(`Failed to create RPC connection: ${t.message}`)}}loadWallet(){const n=process.env.PRIVATE_KEY;if(!n)throw new Error("PRIVATE_KEY not defined in .env");try{const i=Uint8Array.from(JSON.parse(n));if(64!==i.length)throw new Error("Invalid private key length");const r=e.fromSecretKey(i);return new t.Wallet(r)}catch(t){throw new Error(`Invalid private key format : ${t.message}`)}}async sendAndConfirmTransaction(t,n,e,a){try{const s=await this.connection.getLatestBlockhash(),o=new i({payerKey:n,recentBlockhash:s.blockhash,instructions:t}).compileToV0Message(a),c=new r(o);c.sign(e);const u=await this.connection.sendTransaction(c);return await this.connection.confirmTransaction({blockhash:s.blockhash,lastValidBlockHeight:s.lastValidBlockHeight,signature:u},"confirmed"),u}catch(t){console.log(t)}}}class p extends m{static async initialize(){return await super.initialize()}async createMainAccount(t,n){let e=[],i=await this.program.methods.createMainAccount(t,n).accounts({owner:this.signer.publicKey}).instruction();return e.push(i),await this.sendAndConfirmTransaction(e,this.signer.publicKey,[this.signer])}async getMainAccountState(t){const n=await this.program.account.mainAccount.fetch(h(Uint8Array.from(t)));return[n.owner,n.globalWhitelistedPayees]}async getSubAccountState(t,n){let e=h(Uint8Array.from(t));const i=await this.program.account.subAccount.fetch(l(e,n));return[i.whitelistedPayees,i.whitelistedTokens,i.paymentInterval,i.paymentCount,i.maxPerPayment,i.lastPaymentTimestamp]}async updateMainAccountRules(t,n){let e=[],i=h(Uint8Array.from(t)),r=await this.program.methods.updateGlobalWhitelistedPayees(n).accounts({owner:this.signer.publicKey,mainAccount:i}).instruction();return e.push(r),await this.sendAndConfirmTransaction(e,this.signer.publicKey,[this.signer])}async updateSubAccountRules(t,n,e,i,r,a,s){let o=[],c=h(Uint8Array.from(t));if(e){let t=await this.program.methods.updateWhitelistedPayees(e).accounts({owner:this.signer.publicKey,agent:n,mainAccount:c}).instruction();o.push(t)}if(i){let t=await this.program.methods.updateWhitelistedTokens(i).accounts({owner:this.signer.publicKey,agent:n,mainAccount:c}).instruction();o.push(t)}if(r){let t=await this.program.methods.updateMaxPerPayment(r).accounts({owner:this.signer.publicKey,agent:n,mainAccount:c}).instruction();o.push(t)}if(a){let t=await this.program.methods.updatePaymentCount(a).accounts({owner:this.signer.publicKey,agent:n,mainAccount:c}).instruction();if(o.push(t),s){let t=await this.program.methods.updatePaymentInterval(s).accounts({owner:this.signer.publicKey,agent:n,mainAccount:c}).instruction();o.push(t)}return await this.sendAndConfirmTransaction(o,this.signer.publicKey,[this.signer])}}async increaseAllowance(t,n,e,i,r,c,u){let l=[],m=h(Uint8Array.from(t)),p=u||o,g=await this.program.methods.increaseSubAccountAllowance(e,i).accounts({owner:this.signer.publicKey,ownerTokenAccount:c||a(r,this.signer.publicKey,!1,p,s),agent:n,mainAccount:m,tokenMint:r,tokenProgram:p}).instruction();return l.push(g),await this.sendAndConfirmTransaction(l,this.signer.publicKey,[this.signer])}async decreaseAllowance(t,n,e,i,r,c,u){let m=[],p=h(Uint8Array.from(t)),g=l(p,this.signer.publicKey),y=u||o,d=await this.program.methods.decreaseSubAccountAllowance(e,i).accounts({owner:this.signer.publicKey,ownerTokenAccount:c||a(r,this.signer.publicKey,!1,y,s),saTokenAccount:a(r,g,!0,y,s),agent:n,mainAccount:p,tokenMint:r,tokenProgram:y}).instruction();return m.push(d),await this.sendAndConfirmTransaction(m,this.signer.publicKey,[this.signer])}async createSubAccount(n,e,i,r,c,u,l,m,p,g,y){let d=[],w=h(Uint8Array.from(n)),f=y||o,A=await this.program.methods.createSubAccount(i,r,c,u,l).accounts({owner:this.signer.publicKey,agent:e,mainAccount:w}).instruction();if(d.push(A),m.gt(new t.BN(0))){if(!p)throw new Error("tokenMint must be specified if allowanceAmount is greater than 0");let t=await this.program.methods.increaseSubAccountAllowance(m,0).accounts({owner:this.signer.publicKey,ownerTokenAccount:g||a(p,this.signer.publicKey,!1,f,s),agent:e,mainAccount:w,tokenMint:p,tokenProgram:f}).instruction();d.push(t)}return await this.sendAndConfirmTransaction(d,this.signer.publicKey,[this.signer])}}class g extends m{static async initialize(){return await super.initialize()}async getMainAccountState(t){const n=await this.program.account.mainAccount.fetch(h(Uint8Array.from(t)));return[n.owner,n.globalWhitelistedPayees]}async getSubAccountState(t){let n=h(Uint8Array.from(t));const e=await this.program.account.subAccount.fetch(l(n,this.signer.publicKey));return[e.whitelistedPayees,e.whitelistedTokens,e.paymentInterval,e.paymentCount,e.maxPerPayment,e.lastPaymentTimestamp]}async paymentRequest(t,n,e,i,r,c){let u=[],m=h(Uint8Array.from(t)),p=l(m,this.signer.publicKey),g=c||o,y=await this.program.methods.paymentRequest(e).accounts({agent:this.signer.publicKey,payee:n,mainAccount:m,saTokenAccount:a(i,p,!0,g,s),payeeTokenAccount:r||a(i,n,!1,g,s),tokenMint:i,tokenProgram:g}).instruction();return u.push(y),await this.sendAndConfirmTransaction(u,this.signer.publicKey,[this.signer])}}export{p as MainAccountTxHandler,g as SubAccountTxHandler};
